<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="description" content ="CS88: Computational Structures in Data Science " />
    <meta name="keywords" content ="CS88, Computer Science, Data Science, Programming, David Culler, Berkeley, EECS" />
    <meta name="author" content ="David Culler, Garrett Tan, Gunjan Baid, Richard Liang, Nishant Desai" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width">

    <script src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>

    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="icon" href="/assets/images/favicon.ico">

    <link rel="stylesheet" href="/assets/css/mono-blue.css">
    <script src="/assets/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" type="text/css" href="/assets/css/resource.css" />
<link rel="stylesheet" type="text/css" href="../../assets/css/hw.css"/>


    <title>Extra Homework 1 | CS 88 Spring 2016</title>

  </head>

  <body id="index" class="home">
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-section">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">CS 88</a>
        </div>

        <div class="collapse navbar-collapse" id="navbar-collapse-section">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="/">Calendar</a></li>
            <li><a href="/articles/resources.html">Resources</a></li>
            <li><a href="/office-hours.html">Office Hours</a></li>
            <!--- <li><a href="/tutoring.html">Tutoring</a></li> -->

            <li><a href="/articles/using-ok.html">Using OK</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Info <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="/articles/about.html">Syllabus</a></li>
                <li><a href="/staff.html">Staff</a></li>
                <!-- <li><a href="/weekly.html">Weekly Schedule</a></li> -->
                <!-- <li><a href="/extra.html">Extra Lectures</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </div>
    </nav>

    <div id="content" class="container">
      <div class='row'>
  <div class='col-md-9'>
    <div class='page-header'>
      <h1><span class="content-title-brand">Extra Homework 1</span></h1>
    </div>

    <p><em>Due by 11:59pm on Monday, 10/12</em></p>

<h2>Instructions</h2>

<p>Download <a href="extra01.zip">
  extra01.zip</a>.  Inside the archive, you will
find a file called <a href="extra01.py">
  extra01.py</a>, along with a copy
of the <a href="ok">OK</a> autograder.</p>

<p><strong>Submission:</strong> When you are done, submit with
<code>python3 ok --submit</code>. You may submit more than once before
the deadline; only the final submission will be scored.</p>

<h2>Using OK</h2>

<p>The <code>ok</code> program helps you test your code and track your progress.
The first time you run the autograder, you will be asked to log in with your
@berkeley.edu account using your web browser. Please do so. Each time you run
ok, it will back up your work and progress on our servers.

You can run all the doctests with the following command:</p>

<pre><code>python3 ok</code></pre>

<p>To test a specific question, use the <code>-q</code> option with the
name of the function:</p>

<pre><code>python3 ok -q &lt;function&gt;</code></pre>

<p>By default, only tests that <strong>fail</strong> will appear. If you
want to see how you did on all tests, you can use the <code>-v</code>
option:</p>

<pre><code>python3 ok -v</code></pre>

<p>If you do not want to send your progress to our server or you have any
problems logging in, add the <code>--local</code> flag to block all
communication:</p>

<pre><code>python3 ok --local</code></pre>

<p>When you are ready to submit, run <code>ok</code> with the
<code>--submit</code> option:</p>

<pre><code>python3 ok --submit</code></pre>

<p><strong>Readings:</strong> You might find the following references
useful:</p>

<ul>
  <li><a href="http://composingprograms.com/pages/16-higher-order-functions.html">Section 1.6</a></li>
  <li><a href="http://composingprograms.com/pages/23-sequences.html#trees">Section 2.3.6</a></li>
</ul>

    


<h2 id="newton-s-method">Newton's Method</h2>


<h3 class="question" id="q1">Question 1</h3>

<p>Implement <code>intersect</code>, which takes two functions <code>f</code> and <code>g</code> and their
derivatives <code>df</code> and <code>dg</code>. It returns an intersection point <code>x</code>, at which
<code>f(x)</code> is equal to <code>g(x)</code>.</p>

<pre><code>def intersect(f, df, g, dg):
    &quot;&quot;&quot;Return where f with derivative df intersects g with derivative dg.

    &gt;&gt;&gt; parabola, line = lambda x: x*x &#x2d; 2, lambda x: x + 10
    &gt;&gt;&gt; dp, dl = lambda x: 2*x, lambda x: 1
    &gt;&gt;&gt; intersect(parabola, dp, line, dl)
    4.0
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"</code></pre>


<h2 id="huffman-encoding-trees">Huffman Encoding Trees</h2>



<h3 id="introduction">Introduction</h3>


<p>We consider the problem of representing text as a sequence of ones and zeros
(bits). As a simpler example, consider encoding an alphabet consisting of only
<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code>, <code>G</code>, and <code>H</code>. We can choose a code with three
bits per character. For example:</p>

<pre>
<code style="color:red">A 000</code>   <code style="color:brown">C 010</code>   <code style="color:gray">E 100</code>   <code style="color:purple">G 110</code>
<code style="color:orange">B 001</code>   <code style="color:green">D 011</code>   <code style="color:blue">F 101</code>   <code style="color:black">H 111</code>
</pre>

<p>With this code, the 18-character message:</p>

<pre>
<code style="color:orange">B</code><code style="color:red">A</code><code style="color:brown">C</code><code style="color:red">A</code><code style="color:green">D</code><code style="color:red">A</code><code style="color:gray">E</code><code style="color:red">A</code><code style="color:blue">F</code><code style="color:red">A</code><code style="color:orange">B</code><code style="color:orange">B</code><code style="color:red">A</code><code style="color:red">A</code><code style="color:red">A</code><code style="color:purple">G</code><code style="color:red">A</code><code style="color:black">H</code>
</pre>

<p>is encoded as the string of 54 bits:</p>

<pre>
<code style="color:orange">001</code><code style="color:red">000</code><code style="color:brown">010</code><code style="color:red">000</code><code style="color:green">011</code><code style="color:red">000</code><code style="color:gray">100</code><code style="color:red">000</code><code style="color:blue">101</code><code style="color:red">000</code><code style="color:orange">001</code><code style="color:orange">001</code><code style="color:red">000</code><code style="color:red">000</code><code style="color:red">000</code><code style="color:purple">110</code><code style="color:red">000</code><code style="color:black">111</code>
</pre>

<p>Codes such as the <code>A</code>-through-<code>H</code> code above (and
<a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>)are known as <strong>fixed-length
codes</strong>, because they represent each symbol in the message with the same number
of bits. It is sometimes advantageous to use <strong>variable-length codes</strong>, in
which different symbols may be represented by different numbers of bits. If our
messages are such that some symbols appear very frequently and some very
rarely, we can encode data more efficiently (i.e., using fewer bits per
message) if we assign shorter codes to the frequent symbols. Consider the
following alternative code for the letters <code>A</code> through <code>H</code>:</p>

<pre>
<code style="color:red">A 0</code>     <code style="color:brown">C 1010</code>   <code style="color:gray">E 1100</code>   <code style="color:purple">G 1110</code>
<code style="color:orange">B 100</code>   <code style="color:green">D 1011</code>   <code style="color:blue">F 1101</code>   <code style="color:black">H 1111</code>
</pre>

<p>With this code, the same message as above is encoded as the string:</p>

<pre>
<code style="color:orange">100</code><code style="color:red">0</code><code style="color:brown">1010</code><code style="color:red">0</code><code style="color:green">1011</code><code style="color:red">0</code><code style="color:gray">1100</code><code style="color:red">0</code><code style="color:blue">1101</code><code style="color:red">0</code><code style="color:orange">100</code><code style="color:orange">100</code><code style="color:red">0</code><code style="color:red">0</code><code style="color:red">0</code><code style="color:purple">1110</code><code style="color:red">0</code><code style="color:black">1111</code>
</pre>

<p>This string contains 42 bits, so it saves more than 20% in space in
comparison with the fixed-length code shown above.</p>

<p>One of the difficulties of using a variable-length code is knowing
when you have reached the end of a symbol in reading a sequence of
zeros and ones. One solution is to design the code in such a way that
no complete code for any symbol is the beginning (or prefix) of the
code for another symbol. Such a code is called a <strong>prefix code</strong>. In
the example above, <code>A</code> is encoded by <code>0</code> and <code>B</code> is encoded by <code>100</code>,
so no other symbol can have a code that begins with <code>0</code> or with <code>100</code>.</p>

<p>In general, we can attain significant savings if we use
variable-length prefix codes that take advantage of the relative
frequencies of the symbols in the messages to be encoded. One
particular scheme for doing this is called <strong>Huffman encoding</strong>, after
its discoverer, David Huffman. A Huffman code can be represented as a
binary tree whose leaves are the symbols that are encoded.</p>

<p>Each symbol at a leaf is assigned a weight (its frequency), and each
non-leaf node contains a weight that is the sum of all the weights of
the leaves lying below it. The weights will be used to help construct
the tree.</p>

<p>The figure below shows the Huffman encoding tree for the
<code>A</code>-through-<code>H</code> prefix code given above. The weights at the leaves
indicate that the tree was designed for messages in which <code>A</code> appears
with frequency 8, <code>B</code> with frequency 3, and the other letters each
with frequency 1.</p>

<p><img class="img-responsive center-block" src="assets/huf.png" alt="Huffman encoding"></p>


<h3 id="decoding">Decoding</h3>


<p>To decode a bit sequence using a Huffman tree, we begin at the root and
use the successive zeros and ones of the bit sequence to determine
whether to move down the left or the right branch. Each time we come to
a leaf, we have generated a new symbol in the message, at which point
we start over from the root of the tree to find the next symbol.</p>

<p>For example, suppose we are given the tree above and the sequence</p>

<pre><code>10001111</code></pre>

<p>Starting at the root, we move down the right branch, (since the first
bit of the string is 1), then down the left branch (since the second
bit is 0), then down the left branch (since the third bit is also 0).
This brings us to the leaf <code>B</code>, so the first symbol of the decoded
message is <code>B</code>.</p>

<p>Now we start again at the root, and we make a left move because the
next bit in the string is 0. This brings us to the leaf <code>A</code>. Then we
start again at the root with the rest of the string 1111, so we move
right, right, right, right and reach <code>H</code>. Thus, the entire message is
<code>BAH</code>.</p>


<h3 id="encoding">Encoding</h3>


<p>Given a Huffman tree, we can enumerate all encodings by traversing the
tree. That is, we can write a function that takes the Huffman tree as
input and returns a dictionary that maps letters (e.g. <code>A</code>) to codes
(e.g. <code>0</code>). Then, encoding a message involves concatenating the code
for each letter in the message.</p>


<h3 id="generating-huffman-encoding-trees">Generating Huffman Encoding Trees</h3>


<p>Given an alphabet of symbols and their relative frequencies, how do we
construct the tree that will encode messages with the fewest bits?
Huffman gave an algorithm for doing this and showed that the resulting
code is indeed the optimal variable-length code (for messages where
the frequency of the symbols to be encoded matches the frequencies
with which the Huffman tree was constructed). You can read more about
the story of how Huffman encoding came to be
<a href="http://www.huffmancoding.com/my-uncle/scientific-american">here</a>.</p>

<p>The algorithm for generating a Huffman tree is very simple. The idea
is to arrange the tree so that the symbols with the lowest frequency
appear farthest away from the root. Start with the set of leaf nodes,
containing symbols and their frequencies in some initial data. Now,
find two nodes with the smallest weights and merge them to produce a
new node, with these two nodes as its left and right branches. The
weight of the new node is the sum of the two weights. Remove the two
leaves from the original set and replace them with this new node.</p>

<p>Repeat. At each step, merge two nodes with the smallest weights,
removing them from the set and replacing them with a node that has
these two as its left and right branches. The process stops when there
is only one node left, which is the root of the entire Huffman tree.</p>

<p>Wikipedia has an excellent <a href="http://en.wikipedia.org/wiki/Huffman_coding#Compression">animation</a> of this process.</p>

<p>Here is how the previous example Huffman tree is generated, where
trees are described by the set of letters they contain, along with their
weight:</p>

<p>Initial leaves:</p>

<pre><code>{(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}</code></pre>

<p>Trees after...</p>

<p>Step 1: <code>{(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}</code></p>

<p>Step 2: <code>{(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}</code></p>

<p>Step 3: <code>{(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}</code></p>

<p>Step 4: <code>{(A 8) (B 3) ({C D} 2) ({E F G H} 4)}</code></p>

<p>Step 5: <code>{(A 8) ({B C D} 5) ({E F G H} 4)}</code></p>

<p>Step 6: <code>{(A 8) ({B C D E F G H} 9)}</code></p>

<p>Step 7: <code>{({A B C D E F G H} 17)}</code></p>

<p>The algorithm does not always specify a unique tree, because there may
not be unique smallest-weight nodes at each step. Also, the choice of
the order in which the two nodes are merged (i.e., which will be the
right branch and which will be the left branch) is arbitrary.</p>

<p>Huffman trees are represented by the following data abstraction, which is
defined in terms of the <code>tree</code> data abstraction from lecture:</p>

<pre><code># Huffman encoding trees

def huffman_leaf(letter, weight):
    &quot;&quot;&quot;A leaf of a Huffman tree, which has a weight at the root.&quot;&quot;&quot;
    return tree(weight, [tree(letter)])

def huffman_tree(left, right):
    &quot;&quot;&quot;A Huffman encoding tree; left and right are also Huffman trees.&quot;&quot;&quot;
    return tree(root(left) + root(right), [left, right])

def weight(tree):
    &quot;&quot;&quot;The weight of a Huffman encoding tree.&quot;&quot;&quot;
    return root(tree)

def is_huffman_leaf(tree):
    &quot;&quot;&quot;Whether this Huffman tree is a Huffman leaf.&quot;&quot;&quot;
    return not is_leaf(tree) and is_leaf(branches(tree)[0])

def letter(leaf):
    &quot;&quot;&quot;The letter of a Huffman leaf.&quot;&quot;&quot;
    return root(branches(leaf)[0])</code></pre>

<p>The <code>A</code>-through-<code>H</code> code above can be implemented as:</p>

<pre><code>CD = huffman_tree(huffman_leaf(&#x27;c&#x27;, 1), huffman_leaf(&#x27;d&#x27;, 1))
EF = huffman_tree(huffman_leaf(&#x27;e&#x27;, 1), huffman_leaf(&#x27;f&#x27;, 1))
GH = huffman_tree(huffman_leaf(&#x27;g&#x27;, 1), huffman_leaf(&#x27;h&#x27;, 1))
EFGH = huffman_tree(EF, GH)
BCD = huffman_tree(huffman_leaf(&#x27;b&#x27;, 3), CD)
BCDEFGH = huffman_tree(BCD, EFGH)
example_tree = huffman_tree(huffman_leaf(&#x27;a&#x27;, 8), BCDEFGH)</code></pre>

<h3 class="question" id="q2">Question 2</h3>

<p>Implement <code>letters</code>, which returns the letters of a Huffman encoding tree in
the numerical order of their encodings.</p>

<pre><code>def letters(tree):
    &quot;&quot;&quot;Return a list of all letters encoded in Huffman encoding TREE.

    &gt;&gt;&gt; letters(example_tree)
    [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;]
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"</code></pre>

<h3 class="question" id="q3">Question 3</h3>

<p>Implement <code>decode_one</code>, which takes as arguments a Huffman tree and a list of
0's and 1's (bits). It returns the first encoded letter in <code>code</code>, while
removing its corresponding bits:</p>

<pre><code>def decode(tree, code):
    &quot;&quot;&quot;Decode CODE, a list of 0&#x27;s and 1&#x27;s using the Huffman encoding TREE.

    &gt;&gt;&gt; decode(example_tree, [1, 0, 0, 0, 1, 1, 1, 1])
    &#x27;bah&#x27;
    &quot;&quot;&quot;
    word = &#x27;&#x27;
    while code:
        word += decode_one(tree, code)
    return word

def decode_one(tree, code):
    &quot;&quot;&quot;Decode and remove the first letter in CODE, using TREE.

    &gt;&gt;&gt; code = [1, 0, 0, 0, 1, 1, 1, 1]
    &gt;&gt;&gt; decode_one(example_tree, code)
    &#x27;b&#x27;
    &gt;&gt;&gt; code # The initial 1, 0, and 0 are removed by decode_one
    [0, 1, 1, 1, 1]
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"</code></pre>

<h3 class="question" id="q4">Question 4</h3>

<p>Implement <code>encodings</code>, which returns the encodings for all letters in
a Huffman tree as a dictionary:</p>

<pre><code>def encodings(tree):
    &quot;&quot;&quot;Return all encodings in a TREE as a dictionary that maps symbols to
    bit lists.

    &gt;&gt;&gt; e = encodings(example_tree)
    &gt;&gt;&gt; set(e.keys()) == set(&#x27;abcdefgh&#x27;)
    True
    &gt;&gt;&gt; e[&#x27;a&#x27;]
    [0]
    &gt;&gt;&gt; e[&#x27;c&#x27;]
    [1, 0, 1, 0]
    &gt;&gt;&gt; e[&#x27;h&#x27;]
    [1, 1, 1, 1]
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"</code></pre>

<h3 class="question" id="q5">Question 5</h3>

<p>Implement <code>huffman</code>, which takes a list of (symbol, frequency) pairs and
outputs an optimal encoding tree. The given code sorts the pairs from
lowest to highest frequency, then creates a Huffman leaf for each pair.</p>

<pre><code>def huffman(frequencies):
    &quot;&quot;&quot;Return a Huffman encoding for FREQUENCIES, a list of (symbol,
    frequency) pairs.

    &gt;&gt;&gt; frequencies = [(&#x27;a&#x27;, 8), (&#x27;b&#x27;, 3), (&#x27;c&#x27;, 1), (&#x27;d&#x27;, 1)]
    &gt;&gt;&gt; h = huffman(frequencies)
    &gt;&gt;&gt; for letter, code in sorted(encodings(h).items()):
    ...     print(letter + &#x27;:&#x27;, code)
    a: [1]
    b: [0, 1]
    c: [0, 0, 0]
    d: [0, 0, 1]
    &quot;&quot;&quot;
    frequencies.sort(key=lambda freq: freq[1]) # lowest frequencies first
    leaves = [huffman_leaf(letter, freq) for letter, freq in frequencies]
    "*** YOUR CODE HERE ***"

def huffman_wiki():
    &quot;&quot;&quot;Return a Huffman encoding tree for the text of the Huffman coding page
    on Wikipedia. (Internet connection required!)

    &gt;&gt;&gt; e = encodings(huffman_wiki())
    &gt;&gt;&gt; [[letter, e[letter]] for letter in [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]]
    [[&#x27;a&#x27;, [0, 0, 1, 0]], [&#x27;b&#x27;, [1, 0, 0, 0, 1, 0]], [&#x27;c&#x27;, [0, 1, 0, 1, 1]]]
    &quot;&quot;&quot;
    from urllib.request import urlopen
    from json import loads
    from collections import Counter
    huff = urlopen(&#x27;http://goo.gl/w1Jdjj&#x27;).read().decode()
    content = loads(huff)[&#x27;query&#x27;][&#x27;pages&#x27;][&#x27;13883&#x27;][&#x27;revisions&#x27;][0][&#x27;*&#x27;]
    return huffman(list(Counter(content).items()))</code></pre>


<h2 id="challenge-questions-newton-s-method">Challenge Questions: Newton's Method</h2>


<h3 class="question" id="q6">Question 6</h3>

<p>Differentiation of polynomials can be performed automatically by applying the
<a href="http://en.wikipedia.org/wiki/Product_rule">product rule</a> and the fact that
the derivative of a sum is the sum of the derivatives of the terms.</p>

<p>In the following example, polynomials are expressed as two-argument Python
functions. The first argument is the input <code>x</code>. The second argument called
<code>derive</code> is <code>True</code> or <code>False</code>. When <code>derive</code> is <code>True</code>, the derivative is
returned. When <code>derive</code> is <code>False</code>, the function value is returned.</p>

<p>For example, the <code>quadratic</code> function below returns a quadratic polynomial.
The linear term <code>X</code> and constant function <code>K</code> are defined using
<a href="https://www.python.org/dev/peps/pep-0308/">conditional expressions</a>.</p>

<pre><code>X = lambda x, derive: 1 if derive else x
K = lambda k: lambda x, derive: 0 if derive else k

def quadratic(a, b, c):
    &quot;&quot;&quot;Return a quadratic polynomial a*x*x + b*x + c.

    &gt;&gt;&gt; q_and_dq = quadratic(1, 6, 8) # x*x + 6*x + 8
    &gt;&gt;&gt; q_and_dq(1.0, False)  # value at 1
    15.0
    &gt;&gt;&gt; q_and_dq(1.0, True)   # derivative at 1
    8.0
    &gt;&gt;&gt; q_and_dq(&#x2d;1.0, False) # value at &#x2d;1
    3.0
    &gt;&gt;&gt; q_and_dq(&#x2d;1.0, True)  # derivative at &#x2d;1
    4.0
    &quot;&quot;&quot;
    A, B, C = K(a), K(b), K(c)
    AXX = mul_fns(A, mul_fns(X, X))
    BX = mul_fns(B, X)
    return add_fns(AXX, add_fns(BX, C))</code></pre>

<p>To complete this implementation and apply Newton's method to polynomials,
fill in the bodies of <code>add_fns</code>, <code>mul_fns</code>, and <code>poly_zero</code> below.</p>

<pre><code>def add_fns(f_and_df, g_and_dg):
    &quot;&quot;&quot;Return the sum of two polynomials.&quot;&quot;&quot;
    "*** YOUR CODE HERE ***"

def mul_fns(f_and_df, g_and_dg):
    &quot;&quot;&quot;Return the product of two polynomials.&quot;&quot;&quot;
    "*** YOUR CODE HERE ***"

def poly_zero(f_and_df):
    &quot;&quot;&quot;Return a zero of polynomial f_and_df, which returns:
        f(x)  for f_and_df(x, False)
        df(x) for f_and_df(x, True)

    &gt;&gt;&gt; q = quadratic(1, 6, 8)
    &gt;&gt;&gt; round(poly_zero(q), 5) # Round to 5 decimal places
    &#x2d;2.0
    &gt;&gt;&gt; round(poly_zero(quadratic(&#x2d;1, &#x2d;6, &#x2d;9)), 5)
    &#x2d;3.0
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"</code></pre>

  </div>

  <div class='col-md-3'>
    <nav class='hidden-print hidden-sm hidden-xs sidebar'>
      <ul>
  <li><a href="#newton-s-method">Newton's Method</a></li>
  <ul>
  <li><a href="#q1">Question 1</a></li>
</ul>

  <li><a href="#huffman-encoding-trees">Huffman Encoding Trees</a></li>
  <ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#decoding">Decoding</a></li>
  <li><a href="#encoding">Encoding</a></li>
  <li><a href="#generating-huffman-encoding-trees">Generating Huffman Encoding Trees</a></li>
  <li><a href="#q2">Question 2</a></li>
  <li><a href="#q3">Question 3</a></li>
  <li><a href="#q4">Question 4</a></li>
  <li><a href="#q5">Question 5</a></li>
</ul>

  <li><a href="#challenge-questions-newton-s-method">Challenge Questions: Newton's Method</a></li>
  <ul>
  <li><a href="#q6">Question 6</a></li>
</ul>

</ul>

    </nav>
  </div>

</div>
    </div>
  </body>
  <script>
  $('.sidebar ul').addClass('nav nav-stacked');
  $('body').scrollspy({
    target: '.sidebar',
    offset: 40
  });
</script>

</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="description" content ="CS88: Computational Structures in Data Science " />
    <meta name="keywords" content ="CS88, Computer Science, Data Science, Programming, Berkeley, EECS" />
    <meta name="author" content ="Gerald Friedland, Gunjan Baid, Anthony Xian" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width">

    <script src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>

    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="icon" href="/assets/images/favicon.ico">

    <link rel="stylesheet" href="/assets/css/mono-blue.css">
    <script src="/assets/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" type="text/css" href="/assets/css/resource.css" />
<link href="../../assets/css/project.css" rel="stylesheet" type="text/css">

    <title>Project 2: Wheel of Fortune | CS 88 Fall 2016</title>

  </head>

  <body id="index" class="home">
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-section">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">CS 88</a>
        </div>

        <div class="collapse navbar-collapse" id="navbar-collapse-section">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="/">Calendar</a></li>
            <li><a href="/articles/resources.html">Resources</a></li>
            <li><a href="/office-hours.html">Office Hours</a></li>
            <li><a href="/articles/about.html">Course Information</a></li>
            <li><a href="/staff.html">Staff</a></li>
            <!--- <li><a href="/tutoring.html">Tutoring</a></li> -->

            <!-- <li><a href="/articles/using-ok.html">Using OK</a></li> -->
<!--             <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Info <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="/articles/about.html">Syllabus</a></li>
                <li><a href="/staff.html">Staff</a></li>
                <li><a href="/weekly.html">Weekly Schedule</a></li>
                <li><a href="/extra.html">Extra Lectures</a></li>
              </ul>
            </li> -->

          </ul>
        </div>
      </div>
    </nav>

    <div id="content" class="container">
      <div class='row'>
  <div class='col-md-9'>
    <div class='page-header'>
      <h1><span class="content-title-brand">Project 2</span>: Wheel of Fortune</h1>
    </div>

    <div id="haiku">
  
</div>

    <h2>Introduction</h2>


<p>In this project, you will create a retro text version of the Wheel of Fortune, a word guessing game.</p>

<p>The project combines functional and object-oriented programming paradigms,
focusing on the material from <a href="http://composingprograms.com/pages/25-object-oriented-programming.html">Chapter 2.5</a> of Composing Programs. The
project also involves understanding, extending, and testing a large program.</p>

<p>The <a href="wheel.zip">wheel.zip</a> archive contains several files.  Your
changes will be made to:</p>

<ul>
  <li><code>board.py</code></li>
  <li><code>game.py</code></li>
  <li><code>player.py</code></li>
  <li><code>secret.py</code></li>
  <li><code>wordset.py</code></li>
</ul>


<p>You can obtain all the files needed for this project by downloading this <a href="Wheel of Fortune.zip">zip archive</a>.</p>

<h2>Logistics</h2>

<p>This is a 20-day project. You may work with one other
partner.  You should not share your code with students who are not your
partner or copy from anyone else's solutions.</p>

<p>In the end, you will submit one project for both partners. The
project is worth 20 points. 18 points are
assigned for correctness, and 2 points for the overall <a
  href="../../articles/composition.html">composition</a> of your program.</p>

<p>You will turn in the following files:</p>


<ul>
  <li><code>answers.txt</code></li>
  <li><code>board.py</code></li>
  <li><code>game.py</code></li>
  <li><code>player.py</code></li>
  <li><code>secret.py</code></li>
  <li><code>wordset.py</code></li>
  <li><code>human_session1.txt</code></li>
  <li><code>computer_session1.txt</code></li>
  <li><code>computer_session2.txt</code></li>
</ul>


<p>You can submit by uploading these files to OK.</p>

<p>You will be able to view your submissions on the <a
  href="http://ok.cs88.org">OK dashboard</a>.</p>

<p>For the functions that we ask you to complete, there may be some
initial code that we provide. If you would rather not use that code,
feel free to delete it and start from scratch. You may also add new
function definitions as you see fit.</p>

<p>However, please do <b>not</b> modify any other functions.  Doing so may
result in your code failing our autograder tests. Also, please do not
change any function signatures (names, argument order, or number of
arguments).</p>


<p>None</p>


<h2>Testing</h2>

<p>Throughout this project, you should be testing the correctness of your
code.  It is good practice to test often, so that it is easy to isolate
any problems.</p>

<p>We have provided an <b>autograder</b> called <code>ok</code> to help you with
testing your code and tracking your progress.</p> 
<!-- The first time you run
the autograder, you will be asked to <b>log in with your OK account using your web browser</b>. Please do so. Each time you run
<code>ok</code>, it will back up your work and progress on our
servers.</p> -->

<p>The primary purpose of <code>ok</code> is to test your implementations, but there
is a catch. At first, the test cases are <i>locked</i>. To unlock tests,
run the following command from your terminal:</p>

<pre><code>python ok -u --local</code></pre>

<p>This command will start an interactive prompt that looks like:</p>

<pre>
=====================================================================
Assignment: Wheel of Fortune
OK, version ...
=====================================================================

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unlocking tests

At each "? ", type what you would expect the output to be.
Type exit() to quit

---------------------------------------------------------------------
Question 0 &gt; Suite 1 &gt; Case 1
(cases remaining: 1)

&gt;&gt;&gt; Code here
?
</pre>

<p>At the <code>?</code>, you can type what you expect the output to be.
If you are correct, then this test case will be available the next time
you run the autograder.</p>

<p>The idea is to understand <i>conceptually</i> what your program should do
first, before you start writing any code.</p>

<p>Once you have unlocked some tests and written some code, you can check
the correctness of your program using the tests that you have
unlocked:</p>

<pre>python ok --local</pre>

<p>Most of the time, you will want to focus on a particular question.
Use the <code>-q</code> option as directed in the problems below.</p>

<p>The <code>tests</code> folder is used to store autograder tests, so make sure
<b>not to modify it</b>. You may lose all your unlocking progress if you
do. If you need to get a fresh copy, you can download the
<a href="Wheel of Fortune.zip">zip archive</a> and copy it over, but you
will need to start unlocking from scratch.</p>




<h2 id="core-concepts">Core Concepts</h2>


<p>This project will give you a chance to work with classes as a means of
composing large software out of well-designed components.  You get to build
a computerized version of the popular American game show <em>Wheel of Fortune</em> using object oriented
programming.  Although the whole project is not very large, we want to give
you the feeling of working with classes at the larger scale.  The game
is built from a collection of classes partitioned into several files.  The
idea is that you should not be looking inside a class when writing code
that uses it.  You should only pay attention to the interface, i.e., the attributes
and methods defined on objects of the class and, to a lesser degree,
the attributes and methods on the class itself.</p>


<h2 id="the-game">The game</h2>


<p>The following shows a little example of playing the game where the computer
picks the word and the human guesses.</p>

<pre><code>[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;a&#x27;, &#x27;t&#x27;]
Guessed chars:  [&#x27;e&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;f&#x27;]
guesser , please enter your next guess.
h

[&#x27;&#x2d;&#x27;, &#x27;h&#x27;, &#x27;a&#x27;, &#x27;t&#x27;]
Guessed chars:  [&#x27;e&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;f&#x27;, &#x27;h&#x27;]
guesser , please enter your next guess.
t
Please enter a single character not yet guessed
w
([&#x27;w&#x27;, &#x27;h&#x27;, &#x27;a&#x27;, &#x27;t&#x27;], 6)
&gt;&gt;&gt;</code></pre>

<p>Of course, why should it be played that way...  You might want to pick the word
and have the computer do the guessing.  Ahh, that would require some data8
thinking.  What letter would be most likely to appear in the word, given all
that you know so far?</p>

<pre><code>&gt;&gt;&gt; inhuman()
picker , pick your secret word.
consecrate
[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;] []

[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;]
Guessed chars:  []
30824  possible words.
Computer guesses:  e
[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;] [&#x27;e&#x27;]

[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;]
Guessed chars:  [&#x27;e&#x27;]
813  possible words.
Computer guesses:  r
[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;] [&#x27;e&#x27;, &#x27;r&#x27;]

[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;]
Guessed chars:  [&#x27;e&#x27;, &#x27;r&#x27;]
25  possible words.
Computer guesses:  a
[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;_&#x27;, &#x27;e&#x27;] [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;]

[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;_&#x27;, &#x27;e&#x27;]
Guessed chars:  [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;]
11  possible words.
Computer guesses:  t
[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;] [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;]

[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;]
Guessed chars:  [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;]
6  possible words.
[&#x27;consecrate&#x27;, &#x27;palpebrate&#x27;, &#x27;perpetrate&#x27;, &#x27;subserrate&#x27;, &#x27;uniserrate&#x27;, &#x27;vertebrate&#x27;]
Computer guesses:  p
[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;] [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;p&#x27;]

&#x2d;&#x2d;&#x2d;&#x2d;&#x2d;

[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;]
Guessed chars:  [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;p&#x27;]
6  possible words.
[&#x27;consecrate&#x27;, &#x27;palpebrate&#x27;, &#x27;perpetrate&#x27;, &#x27;subserrate&#x27;, &#x27;uniserrate&#x27;, &#x27;vertebrate&#x27;]
Computer guesses:  s
[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;s&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;] [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;p&#x27;, &#x27;s&#x27;]

&#x2d;&#x2d;&#x2d;&#x2d;&#x2d;

[&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;s&#x27;, &#x27;e&#x27;, &#x27;_&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;]
Guessed chars:  [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;p&#x27;, &#x27;s&#x27;]
3  possible words.
[&#x27;consecrate&#x27;, &#x27;subserrate&#x27;, &#x27;uniserrate&#x27;]
Computer guesses:  c
[&#x27;c&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;s&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;] [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;p&#x27;, &#x27;s&#x27;, &#x27;c&#x27;]

&#x2d;&#x2d;&#x2d;&#x2d;&#x2d;

[&#x27;c&#x27;, &#x27;_&#x27;, &#x27;_&#x27;, &#x27;s&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;]
Guessed chars:  [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;p&#x27;, &#x27;s&#x27;, &#x27;c&#x27;]
1  possible words.
[&#x27;consecrate&#x27;]
Computer guesses:  n
[&#x27;c&#x27;, &#x27;_&#x27;, &#x27;n&#x27;, &#x27;s&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;] [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;p&#x27;, &#x27;s&#x27;, &#x27;c&#x27;, &#x27;n&#x27;]

&#x2d;&#x2d;&#x2d;&#x2d;&#x2d;

[&#x27;c&#x27;, &#x27;_&#x27;, &#x27;n&#x27;, &#x27;s&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;]
Guessed chars:  [&#x27;e&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;p&#x27;, &#x27;s&#x27;, &#x27;c&#x27;, &#x27;n&#x27;]
1  possible words.
[&#x27;consecrate&#x27;]
Computer guesses:  o
([&#x27;c&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;s&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;], 9)</code></pre>

<p>And why should we settle for just a two-player game.  Let's get all <em>wheel of fortune</em>
and allow multiple guessers.</p>

<h2 id="the-code">The Code</h2>


<p>Most concepts in the game have a corresponding class that encapsulates
the logic for that concept. To make this project concrete,
we have gone through a process similar to what
we did together in lab to design a set of classes for this game.  In the
project you will implement these classes, but hopefully in the future,
when you are designing software systems from scratch, this will help you
think about that design process.</p>

<p>The classes go together to make a game flow such as the following 2-player
game with a computer picking the word and the human guessing the letters:</p>

<pre><code>from wordset import Dictionary
from player import Player, ComputerPlayer, HumanPlayer
from game import Game

def human_plays():
    dictionary = Dictionary(&quot;assets/lincoln.txt&quot;)
    Player(dictionary)
    picker = ComputerPlayer()
    guesser = HumanPlayer(&quot;guesser&quot;)
    game = Game(picker, [guesser] )
    board =  game.play(True)
    print(&quot;Solved &quot;, board.word(),&quot; in &quot;,len(board.guesses()), &quot;guesses&quot;)

if __name__ == &quot;__main__&quot;:
    human_plays()</code></pre>

<p>The <code>Dictionary</code> class takes a path for a file, reads in the file and extracts all
the words in it to build a set of words to be used for the game. (Here we are using
Lincoln's Gettysburg address.)</p>

<p><code>Player</code> is a base player class defines the interface used by all type of players.  In constructing it,
a common dictionary is made available to all the player objects that may be involved
in the game. Two player classes are derived from <code>Player</code>; they are <code>HumanPlayer</code> and
<code>ComputerPlayer</code>.  We will look at these in more detail below.  One player <em>picks</em> the
word.  The other player (or players)
take turns guessing.  Here, like a conventional computer game, the <code>ComputerPlayer</code>
object picks the word and the <code>HumanPlayer</code> object guesses - by allowing you to type
to it.
<br/>

We build a <code>Game</code> with these players.  We then let the <code>Game.play</code> method
carryout the whole process - ask the <em>picker</em> player for the secret word, hide that, create
a <code>Board</code>, cycle through the <em>guessers</em> letting them guess until they miss.
<br/>

When the game is all done, the <code>board</code> object is returned, conveying
the entire history of play.</p>

<p>These classes are defined in several small files.  We briefly describe the classes here.
You will implement most of them, testing as you go.</p>

<p>To start a human player version of text-based game, run</p>

<pre><code>python human.py</code></pre>


<h3 id="secret-words">Secret Words</h3>


<p>The <code>SecretWord</code> class represents the secret word that the picker has
in mind and the guesser(s) need to guess.  It is implemented in <code>secret.py</code>.  It has four
special methods and <code>match</code>.  Collectively, these provide the
abstraction of hiding a secret word.  An object is constructed with
the word hidden inside.  (You'll need to use an attribute for that.)
The <code>__repr__</code> and <code>__str__</code> special methods are written for you (to
suggest that the word is secret). The object can be asked for the
length of the secret word (<code>len</code> of the object) and <code>match</code> can be
given a character which it matches against the secret word and returns
a list of indices of characters that match.  Notice that the doctest
is on the class.  It shows how the methods work together. It does nor
reveal the object attributes that might be used, nor the
representation.</p>


<h3 id="word-sets">Word Sets</h3>


<p>The <code>WordSet</code> class represents what the players keep in their heads - a bunch of words.
It is implemented in the file <code>wordset.py</code>.  A WordSet is constructed
by providing it a text string or a list of words. In the first case, it splits the string
into words.  In either case, it strips out the punctuation (remember <code>string.punctuation</code>)
and converts the word to lowercase.  (A function is provided in <code>utils.py</code> to help with that.)
Each word should appear only once in the <code>WordSet</code>, i.e., eliminate the duplicates.
<br/>

The <code>words</code> method returns a sorted list of the words in the WordSet.
This does not mean that they are represented internally as a sorted
list, but that is certainly one option.  The <code>__contains__</code> special
method tests whether a word is in the <code>WordSet</code>.  This allows the <code>in</code>
operator to be used in expressions with a <code>WordSet</code> as shown in the
doctest.  You are to implement the three methods.  You can use
whatever data structure you like to store the words, but you might
want to look at <code>set</code>.</p>


<h3 id="dictionary">Dictionary</h3>


<p>The <code>Dictionary</code> class represents the set of words that is being used
in the game.  Only words in the dictionary can be picked.  It is also
in <code>wordset.py</code>.  It inherits from <code>WordSet</code> but redefines the
<code>__init__</code> method to obtain the words from a file.  We have
implemented this for you in order to show the preferred method of
opening and reading a tile.</p>

<pre><code>#
# Dictionary class
#
class Dictionary(WordSet):
    &quot;&quot;&quot;Construct a dictionary from all the words in a text file.
    Subclass of WordSet with a file based initializer.

    &gt;&gt;&gt; from wordset import Dictionary
    &gt;&gt;&gt; Dictionary(&#x27;assets/lincoln.txt&#x27;).words()[55]
    &#x27;government&#x27;
    &quot;&quot;&quot;
    def __init__(self, filename):
        with open(filename) as fp:
            text = fp.read()
            WordSet.__init__(self, text)</code></pre>

<p>Notice also how it uses the superclass to invoke the initialization method in that
class.</p>


<h3 id="board">Board</h3>


<p>The <code>Board</code> class represents the board that holds the state of the game.
Logically, it holds the sequence of spaces that represent the characters to be
guess in the secret word.  It also keeps track of all the characters that have been
guess so far.  When it is created it is provided with a <code>SecretWord</code> object that
encapsulates the secret word.  It never peeks inside, but it holds on to it.
The <code>Board</code> object provides a set of methods that allow players to get information
about the board - the length of the word that is being guessed, the list of characters
that have been guessed so far, with the unguessed positions represented by <code>&#x27;_&#x27;</code>,
the guesses, hits, and misses so far.</p>

<p>It also has methods that are used to play on the board.  The <code>guess</code> method is the
main operation that moves the game forward.  When a player guesses a character, it
is applied to the board using this method. The <code>done</code> method determines if the entire
word has been guessed, i.e., the game is done.</p>

<p>We have provided you with the <code>display</code> method, which presents the state of the board
to the screen for the human user.  It reads the little stick figures from text files
in <code>assets</code>.</p>


<h3 id="player">Player</h3>


<p>The <code>Player</code> class is a base class that provides only an interface.
It is in <code>player.py</code>.  This interface is used by all types of players.
The init method receives a dictionary that is to be used by all
players.  It uses this to set the <em>class attribute</em> all_words.</p>


<h3 id="humanplayer">HumanPlayer</h3>


<p>The <code>HumanPlayer</code> class inherits from <code>Player</code> and implements that
interface.  It provides the interface to screen and keyboard to
support the human player. We have provided this for you so that you do
not need to worry about how to format the I/O.</p>

<pre><code>class HumanPlayer(Player):
    &quot;&quot;&quot;HumanPlayer is initialized with a name and implements the player interface
    such that:
    &#x2d; guess requests a guess from a person, via the input device
    &#x2d; pick_word requests a secret word and verifies that it is in the dictionary

    &quot;&quot;&quot;
    def __init__(self, name):
        self.name = name

    def guess(self, board):
        &quot;&quot;&quot;Guess a character.&quot;&quot;&quot;

        print(self.name, &quot;, please enter your next guess.&quot;)
        guess = input()
        while (len(guess) != 1) or (guess in board.guesses()):
            print(&#x27;Please enter a single character not yet guessed&#x27;)
            guess = input()
        return guess

    def pick_word(self):
        &quot;&quot;&quot;Return a secret word from the dictionary.&quot;&quot;&quot;

        print(self.name,&quot;, pick your secret word.&quot;)
        word = input()
        while not word in Player.all_words:
            print(word, &quot; is not in the dictionary. Another:&quot;)
            word = input()
        return word</code></pre>

<p>The <code>pick_word</code> method asks the human for a word and makes sure that it is
in the dictionary.  The <code>guess</code> method asks the human for a character and
makes sure that it is a valid guess.</p>


<h3 id="computerplayer">ComputerPlayer</h3>


<p>The <code>ComputerPlayer</code> class is the fun part.  It has the same methods as the
<code>HumanPlayer</code> but it has to do inference in the characters that have been
guessed so far, looking at the dictionary, in order to make a good guess.
You get to have fun with how it might pick words for you to guess.</p>


<h3 id="wordmunch">WordMunch</h3>


<p>The <code>WordMunch</code> class is also in <code>wordset.py</code>.  This is designed to help your ComputerPlayer.
Think about how you are going to guess characters from looking at the board and looking
at the dictionary.  What are the tricks that you use when you guess?  Generally you start with
<code>e</code> because it is the most frequently used character in the English language.
<br/>
<code>WordMunch</code> inherits from <code>WordSet</code> and is intended to hold smaller and smaller set of words, typically
starting with the full dictionary, as the guesses narrow down the possible words that could
be the secret word.  The
<code>frequency</code> method computes the number of times each lowercase character occurs in all the words
contained in the WordSet. The <code>filter</code> method discards all the words that don't satisfy some
predicate, as specified by the higher order function that is passed to it.  It applies the
function to every word, keeps the ones that come out Truth-y and discards the others, thereby
narrowing down the possibilities.</p>


<h3 id="game">Game</h3>


<p>The <code>Game</code> class implements the taking turns among players.  It is in <code>game.py</code>.  The
initialization receives the player objects - the picker and all the guessers.  The <code>play</code>
method carries out the logic of the game.  It has the picker pick a word.  Makes a secret
out of it.  Creates the initial board with this secret.  It then cycles through the guessers,
giving each a chance to guess repeatedly until it misses.  The <code>winner</code> method returns
the player that won the game after it is done.</p>


<h2 id="problems">Problems</h2>


<p>Now that we have introduced you to the design of all the classes, it's time to
get to work building the game.</p>


<h3 id="problem-0-1-pts">Problem 0 (1 pts)</h3>


<p>Answer the following questions with your partner after you have read
the <em>entire</em> set <code>*.py</code> files.  If you cannot answer these questions,
read the file again or ask a question on Piazza.</p>

<ul>
  <li>In <code>SecretWord</code>, you want the secret word to be private.  How do you
  name object attributes to indicate that it is private?</li>
  <li>What data structures could be used to hold the word set? What would make
  one choice better than another?</li>
  <li>Why is it important that <code>WordSet.words</code> return a sorted list of words in
  the word set, when all we use it for is to test if a word is <code>in</code> the WordSet?</li>
  <li>How does <code>Dictionary</code> invoke the initializer for its superclass?</li>
  <li>Do <code>Players</code> ever access the <code>SecretWord</code> object?  What does <code>Board</code>
  reveal about the secret word?</li>
  <li>How will object methods of subclasses of <code>Player</code> access the <code>all_words</code> class attribute?</li>
  <li>Why does the <code>Player</code> base class define methods that don't do anything?</li>
</ul>

<p>Put your answers in a text file titled <code>answers.txt</code> and submit with your project.</p>


<h3 id="problem-1-3-pts">Problem 1 (3 pts)</h3>


<p>Complete the implementation of the <code>__init__</code>, <code>__len__</code>, and <code>match</code> methods in
the <code>SecretWord</code> class in file <code>secret.py</code>.</p>

<p>Test your implementation before moving on:</p>

<pre><code>python ok &#x2d;q SecretWord &#x2d;&#x2d;local</code></pre>


<h3 id="problem-2-2-pt">Problem 2 (2 pt)</h3>


<p>Complete the implementation of <code>WordSet</code>.</p>

<p>Test your implementation before moving on:</p>

<pre><code>python ok &#x2d;q WordSet &#x2d;&#x2d;local</code></pre>

<p>Now that you have a <code>WordSet</code>, verify that you also have a working <code>Dictionary</code> that inherits
from this.  You didn't have to build the Dictionary, but you need to make sure that the
one we provided works with your <code>WordSet</code>.</p>

<p>Test our implementation before moving on:</p>

<pre><code>python ok &#x2d;q Dictionary &#x2d;&#x2d;local</code></pre>


<h3 id="problem-3-3-pt">Problem 3 (3 pt)</h3>


<p>Complete the implementation of <code>Board</code>.  Please note that this has several small methods that
work together.  The doctest tests them in combination.  It does not depend on the representation
that you choose to use for the board and for keeping track of the letters than have been
guessed, hits, or misses.  You will need to decide on the representation.  And you will likely
want to produce tests for your individual methods.</p>

<p>Test your implementation before moving on:</p>

<pre><code>python ok &#x2d;q Board &#x2d;&#x2d;local</code></pre>


<h3 id="problem-4-3-pt">Problem 4 (3 pt)</h3>


<p>Complete the implementation of <code>Player</code>.  This is just the
initialization method to set the class attribute.</p>

<p>Test your implementation before moving on:</p>

<pre><code>python ok &#x2d;q Player &#x2d;&#x2d;local</code></pre>

<p>Complete the implementation of the <code>pick_word</code> method of <code>ComputerPlayer</code>.  You don't
need the (much bigger) guess method.</p>

<p>Test your implementation before moving on.  This you will have to do by exercising
your <code>ComputerPlayer.pick_word</code>.  Since it needs to yield a random word, it is hard
to test deterministically.  It is very simple, but make sure it works.  Hint: you
will want to look at <code>random.sample</code>.</p>

<p>Complete the implementation of the <code>Game</code> class in <code>game.py</code>.
<br/>

The init method is provided with a player object that is the picker
and a list of players that are the guesses.  The game engine is the
<code>play</code> method.  It gets the secret word from the picker, turns it into
a SecretWord object and creates the board with this secret. Then it
cycles through the guessers until the game is done.  A guesser player
is presented with the board by invoking its <code>guess</code> method.  The
resulting guessed character is the played onto the board with the
board's <code>guess</code> method.  If the guess is successful, the player gets
to keep playing.  When it missed, the next player gets a turn.
Finally, the <code>winner</code> method can be invoked when the game is over to
obtain the winning player.</p>

<p>Testing the game is a little trickier, because it normally works with player object
that take human input or have non-deterministic behavior.  We've provided
dummy players that you can test your <code>Game</code> against these before you
connect your <code>HumanPlayer</code> and picker-only version of <code>ComputerPlayer</code>.</p>

<p>Test your implementation before moving on:</p>

<pre><code>python ok &#x2d;q Game &#x2d;&#x2d;local</code></pre>

<p>At this point you should have a complete human player game.  Run:</p>

<pre><code>python human.py</code></pre>

<p>Cut and paste an example session with computer picking a word and the human guessing
letters.  <em>Submit</em> this as <code>human_session1.txt</code>.</p>

<p>Have fun.  When you get tired of Lincoln, go find a more interesting book to use for words.  The
bigger the book the better chance you'll have against the machine. You can grab Shakespeare from
the earlier homework.  Or on Unix machines, including macs, you can use <code>/usr/share/dict/words</code>.
Have fun.</p>


<h3 id="problem-5-4-pt">Problem 5 (4 pt)</h3>


<p>Now you get to turn the tables and build the computer guesser.  You will do
a sequence of implementations of the <code>guess</code> method in <code>ComputerPlayer</code>.  The
first step is to use the dictionary in the board and WordMunch to get a set of
words to work with in making guesses.  As a start, guess the most frequent letter
that has not been guessed.  Try this out using.</p>

<pre><code>python computer.py</code></pre>

<p>You get to pick words and see what this algorithm has trouble with.  Observe how many
guesses it takes to guess words that you give it.</p>

<p>Next, filter out all the words in the dictionary that are not the correct length.  You can use
the frequencies of letters in the filtered list to make your guess.</p>

<p>Cut and paste an example session with computer guessing a word you pick.
<em>Submit</em> this as <code>computer_session1.txt</code>.</p>

<p><em>Note:</em> We will be providing an additional test for this case and the next well before you get to it.</p>


<h3 id="problem-6-2-pt">Problem 6 (2 pt)</h3>


<p>Improve your <code>ComputerPlayer</code> by using character frequency in the
filtered subset of the dictionary consisting of words of the right
length.  At each successive guess, use the correctly guessed
characters to filter out words of the right length that do not match
these characters.</p>

<p>Cut and paste an example session with computer guessing a word you pick.
Submit this as <code>computer_session2.txt</code>.</p>

<p>Once you have completed all questions, you can run all the OK tests at once using the command below.</p>

<pre><code>python ok &#x2d;&#x2d;local</code></pre>

<p>Congratulations on finish the project!</p>


<h3 id="extra-credit-2-pts">Extra Credit (2 pts)</h3>

<p>You can choose one of the options below to receive 2 additional points for the project. The tasks below are fairly open-ended, we want you to get creative! If you choose to complete the extra credit, please submit a text file called <code>extra_credit.txt</code> to the <code>Wheel of Fortune (Extra Credit)</code> assignment on OK. Please make sure you submit to the extra credit assignment (not the <code>Wheel of Fortune</code> assignment) in order to get credit. This text file should contain a description of the code you wrote, sample output from the game (if that helps explain the improvements), and a list of the files where the extra credit code is located. Make sure to add your partner to the extra credit assignment as well. 
<br/>

<ul>
  <li>Implement a multiplayer version of computer player.</li>
  <li>Instead of character frequencies for all unused characters in the possible words,
  look at character frequencies for the specific unguessed slots.  Build a frequency
  per slot and use that in making the guess.</li>
  <li>While it might seem wise to make the most likely guess, a rather different choice is the guess that
  will put you on the shortest path (fewest misses) to a unique determination.  Once you know the
  word you should not miss at all.  This approach introduces a bit of a search tree.</li>
  <li>Come up with better ways of guessing, such as looking at character combinations.  Show how
  much better these perform than simply filtering on length and match.</li>
</ul></p>

  </div>

  <div class='col-md-3'>
    <nav class='hidden-print hidden-sm hidden-xs sidebar'>
      <ul>
  <li><a href="#core-concepts">Core Concepts</a></li>
  <li><a href="#the-game">The game</a></li>
  <li><a href="#the-code">The Code</a></li>
  <ul>
  <li><a href="#secret-words">Secret Words</a></li>
  <li><a href="#word-sets">Word Sets</a></li>
  <li><a href="#dictionary">Dictionary</a></li>
  <li><a href="#board">Board</a></li>
  <li><a href="#player">Player</a></li>
  <li><a href="#humanplayer">HumanPlayer</a></li>
  <li><a href="#computerplayer">ComputerPlayer</a></li>
  <li><a href="#wordmunch">WordMunch</a></li>
  <li><a href="#game">Game</a></li>
</ul>

  <li><a href="#problems">Problems</a></li>
  <ul>
  <li><a href="#problem-0-1-pts">Problem 0 (1 pts)</a></li>
  <li><a href="#problem-1-3-pts">Problem 1 (3 pts)</a></li>
  <li><a href="#problem-2-2-pt">Problem 2 (2 pt)</a></li>
  <li><a href="#problem-3-3-pt">Problem 3 (3 pt)</a></li>
  <li><a href="#problem-4-3-pt">Problem 4 (3 pt)</a></li>
  <li><a href="#problem-5-4-pt">Problem 5 (4 pt)</a></li>
  <li><a href="#problem-6-2-pt">Problem 6 (2 pt)</a></li>
  <li><a href="#extra-credit-2-pts">Extra Credit (2 pts)</a></li>
</ul>

</ul>

    </nav>
  </div>

</div>
    </div>
  </body>
  <script>
  $('.sidebar ul').addClass('nav nav-stacked');
  $('body').scrollspy({
    target: '.sidebar',
    offset: 40
  });
</script>

</html>
